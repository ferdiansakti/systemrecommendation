# -*- coding: utf-8 -*-
"""System Recommendation (Ferdian Sakti).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PPXoMaz6RG-fFvl9U7XTchgk7BeC-lzP

# **1. Mengimpor library yang diperlukan**
"""

# Import library yang diperlukan
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from difflib import get_close_matches
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from tabulate import tabulate

"""# **2. Data Understanding**

Memuat dataset dari file CSV ke dalam variabel DataFrame.
"""

# Load dataset
anime_df = pd.read_csv("/content/sample_data/top_anime_dataset.csv")

# Tampilkan sampel data
print("Sampel Data Anime:")
print(anime_df.head())

"""Memuat dataset dari file CSV ke dalam variabel DataFrame."""

# Informasi dataset
print("Info Dataset:")
print(anime_df.info())

"""Ringkasan dataset :


1.   Jumlah Total Baris (Data/Entitas): 10.000
2.   Jumlah Total Kolom (Fitur/Variabel): 6
"""

# Cek nilai null
print("Missing Values:")
print(anime_df.isnull().sum())

"""Tidak terdapat nilai null (missing value) dari struktur dataset tersebut."""

# Statistik deskriptif
print("Statistik Deskriptif Dataset:")
print(anime_df.describe())

"""**Ringkasan Analisis Statistik Deskriptif:**

- Rating Anime :
1. Rata-rata: 6.94 (standar deviasi rendah = 0.63), menunjukkan konsistensi.
2. 75% anime memiliki rating â‰¥6.42, dengan nilai tertinggi 9.32.

- Peringkat (Ranked)
1. Distribusi merata dari peringkat 1â€“10.000 (mean = 5000.5).
2. Tidak ada korelasi langsung dengan rating.

- Insight
1. Mayoritas anime berkualitas baik (rating >6.4).
2. Peringkat tidak dipengaruhi oleh rating, mungkin tergantung popularitas.
"""

# Distribusi Rating Anime
plt.figure(figsize=(12, 6))
sns.histplot(anime_df['Rating'], bins=30, kde=True, color='skyblue')
plt.title('Distribusi Rating Anime')
plt.xlabel('Rating')
plt.ylabel('Frekuensi')
plt.show()

"""**Kesimpulan Distribusi Rating Anime**
1. Dominasi Rating Menengah
- Sebagian besar anime terkonsentrasi pada rentang 6.5â€“7.5, menunjukkan kualitas rata-rata yang stabil.
2. Sedikit Anime dengan Rating Ekstrem
- Rating di atas 8.0 sangat jarang (jumlah anime turun drastis).
- Hanya segelintir anime yang mencapai rating 9.0 (kualitas exceptional).
3. Distribusi Miring ke Kanan
- Ekor panjang di sisi kanan (rating tinggi) mengindikasikan adanya beberapa anime dengan performa luar biasa.
4. Implikasi
- Sistem rekomendasi yang dibangun ini perlu mempertimbangkan rating tinggi sebagai outlier (langka tetapi bernilai).
- Fokus pada anime dengan rating 6.5â€“7.5 akan mencakup mayoritas konten.
"""

# Top Anime Berdasarkan Rating
top_rated = anime_df.nlargest(10, 'Rating')[['Name', 'Rating', 'Type']]
print("Top 10 Anime Berdasarkan Rating:")
print(top_rated)

"""**Kesimpulan Top 10 Anime Berdasarkan Rating**
1. Dominasi Genre Shounen/Seinen
- 9 dari 10 anime teratas merupakan serial TV (bertipe "TV"), dengan dominasi genre action/adventure seperti Fullmetal Alchemist dan Hunter x Hunter.
2. Eksklusivitas Rating Tinggi
- Semua anime memiliki rating di atas 9.0, menunjukkan kualitas yang sangat istimewa dan konsisten.
- Sousou no Frieren memuncaki daftar dengan rating 9.32.
"""

# 2.3. Distribusi Tipe Anime (Pie Chart)
plt.figure(figsize=(8, 6))
type_counts = anime_df['Type'].value_counts()

# Create pie chart
plt.pie(type_counts,
        labels=type_counts.index,
        autopct='%1.1f%%',
        startangle=90,
        colors=['#66b3ff','#99ff99','#ffcc99','#ff9999','#cc99ff'],
        wedgeprops={'edgecolor': 'white', 'linewidth': 1})

# Add title and make it look nice
plt.title('Distribusi Tipe Anime', pad=20, fontsize=15)
plt.axis('equal')  # Equal aspect ratio ensures pie is drawn as circle

plt.tight_layout()
plt.show()

"""**Kesimpulan Distribusi Tipe Anime**
1. Dominasi Anime TV
- 46.7% dari total anime merupakan tipe TV (serial televisi), menunjukkan format ini paling populer dalam industri.
2. Konten Alternatif Signifikan
- OVA (12.5%) dan ONA (12.7%) bersama-sama menyumbang 25.2%, mencerminkan tren konten digital/eksklusif yang berkembang.
3. Film Anime (Movie)
- 17.5% berbentuk film, presentase yang cukup tinggi.
4. Konten Spesial & Unknown
- Special (10.6%): Biasanya berupa episode bonus atau OVA pendek.
- Unknown (0.0%): Tidak ada data yang tidak teridentifikasi.
"""

# Analisis Boxplot Rating per Tipe Anime
plt.figure(figsize=(12, 6))
sns.boxplot(x='Type', y='Rating', data=anime_df)
plt.title('Distribusi Rating per Tipe Anime')
plt.xticks(rotation=45)
plt.show()

"""**Berdasarkan boxplot "Distribusi Rating per Tipe Anime", berikut beberapa kesimpulan yang dapat diambil:**

1. Peringkat Tertinggi secara Median
- Movie memiliki median rating tertinggi dibandingkan tipe anime lainnya.
- Diikuti oleh TV, sementara Special, ONA, dan OVA memiliki median yang lebih rendah.
2. Variasi Rating
- Semua tipe anime kecuali Unknown menunjukkan variasi (interquartile range/IQR) yang cukup besar, yang berarti persebaran nilai rating cukup lebar.
3. Outlier
- Hampir semua kategori (TV, OVA, ONA, Special) menunjukkan adanya outlier pada sisi atas, menunjukkan beberapa anime dengan rating sangat tinggi.
- TV memiliki lebih banyak outlier dibandingkan yang lain, mengindikasikan adanya beberapa anime yang sangat populer.
4. Rentang Rating
Semua tipe (kecuali Unknown) memiliki rentang rating yang mirip, umumnya antara sekitar 6.0 hingga 9.0+.
"""

# Tren Rating Anime
# Konversi Members ke numeric dengan menghilangkan 'members' dan koma
anime_df['Members'] = anime_df['Members'].str.replace(' members', '')  # Hapus teks 'members'
anime_df['Members'] = anime_df['Members'].str.replace(',', '')  # Hapus koma sebagai thousand separator
anime_df['Members'] = anime_df['Members'].astype(int)  # Konversi ke integer

plt.figure(figsize=(12, 6))
sns.scatterplot(x='Rating', y='Members', data=anime_df,
                hue='Type', alpha=0.6, palette='viridis', size='Members', sizes=(20, 200))
plt.title('Hubungan Rating vs Jumlah Members (Skala Logaritmik)')
plt.xlabel('Rating')
plt.ylabel('Jumlah Members (log scale)')
plt.yscale('log')  # Gunakan skala logaritmik karena range members sangat besar
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

"""**Kesimpulan yang dapat diambil dari visualisasi "Hubungan Rating vs Jumlah Members (Skala Logaritmik)":**

1. Korelasi Positif antara Rating dan Jumlah Members
- Secara umum, terdapat hubungan positif antara rating dan jumlah members. Artinya, anime dengan rating yang lebih tinggi cenderung memiliki lebih banyak members (penggemar/penonton).
2. Distribusi Logaritmik yang Luas
- Dengan menggunakan skala logaritmik pada sumbu jumlah members, terlihat bahwa jumlah anggota sangat bervariasi â€” mulai dari ribuan hingga jutaan â€” yang tidak terlihat jelas dalam skala linear.
3. Dominasi Anime Tipe TV
- Tipe anime TV mendominasi pada semua tingkat rating dan jumlah members. Banyak anime TV memiliki jutaan members dan rating tinggi, ditunjukkan oleh ukuran lingkaran besar dan warna ungu dominan di bagian kanan atas grafik.
4. Kepadatan Data pada Rating 6.5 - 8.5
- Sebagian besar anime terkonsentrasi pada rentang rating 6.5 hingga 8.5, dengan jumlah members mulai dari puluhan ribu hingga jutaan.

# **3. Data Preparation**
"""

# Mengecek data duplikat
anime_df.duplicated().sum()

# Konversi kolom 'Popularity' dan 'Members' menjadi numerik
anime_df['Popularity'] = pd.to_numeric(anime_df['Popularity'], errors='coerce')
anime_df['Members'] = pd.to_numeric(anime_df['Members'], errors='coerce')

# Bersihkan dan tambahkan fitur gabungan
anime_df['combined_features'] = anime_df['Name'] + ' ' + anime_df['Type']

# TF-IDF Vectorizer
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(anime_df['combined_features'])

"""# **4. Data Modelling & Result**"""

# Hitung cosine similarity antar anime
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

# Mapping dari nama anime ke indeks
indices = pd.Series(anime_df.index, index=anime_df['Name']).drop_duplicates()

# Fungsi untuk menemukan judul terdekat
def find_closest_title(title):
    matches = get_close_matches(title, anime_df['Name'], n=1, cutoff=0.6)
    return matches[0] if matches else None

# Fungsi rekomendasi berbasis Content Based Learning
def content_based_recommendation(title):
    closest_title = find_closest_title(title)
    if not closest_title:
        print(f"âŒ '{title}' tidak ditemukan.")
        return pd.DataFrame()

    idx = indices[closest_title]
    sim_scores = list(enumerate(cosine_sim[idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:31]  # Ambil 30 teratas

    anime_indices = [i[0] for i in sim_scores]
    similar_animes = anime_df.iloc[anime_indices].copy()

    # Tampilkan langsung berdasarkan skor kemiripan
    similar_animes['similarity_score'] = [score[1] for score in sim_scores]

    # Urutkan berdasarkan similarity score
    top_recommended = similar_animes.sort_values(by='similarity_score', ascending=False).head(10)

    return top_recommended[['Name', 'Type', 'similarity_score']]

# Contoh penggunaan
input_title = "Dragon Ball"
recommendations = content_based_recommendation(input_title)

print(f"\nðŸŽ¬ Rekomendasi Anime Mirip '{input_title}':")
if not recommendations.empty:
    table = recommendations[['Name', 'Type']].reset_index(drop=True)
    table.index += 1  # Tambah penomoran mulai dari 1
    print(tabulate(table, headers=["No", "Name", "Type"], tablefmt="fancy_grid", showindex=True))
else:
    print("Tidak ada rekomendasi yang dapat diberikan.")

"""# **5. Evaluation**"""

# Evaluasi Precision berdasarkan relevansi (Type + Rating threshold)
if not recommendations.empty:
    # Dapatkan info anime input
    input_anime = anime_df[anime_df['Name'] == input_title]
    if input_anime.empty:
        closest_title = find_closest_title(input_title)
        input_anime = anime_df[anime_df['Name'] == closest_title]

    input_type = input_anime.iloc[0]['Type'].lower()
    input_rating = float(input_anime.iloc[0]['Rating'])

    # Hitung rekomendasi yang relevant (tipe sama DAN rating >= 5)
    relevant_recommendations = recommendations[
        (recommendations['Type'].str.lower() == input_type) &
        (recommendations['Rating'] >= 5)
    ]

    # Hitung Precision
    precision = (len(relevant_recommendations) / len(recommendations)) * 100

    # Tampilkan hasil
    print(f"\nðŸŽ¯ Precision: {precision:.2f}%")
    print(f"â€¢ Relevansi dihitung berdasarkan:")
    print(f"  1. Type sama dengan '{input_title}' ({input_type})")
    print(f"  2. Rating â‰¥ 5 (threshold)")